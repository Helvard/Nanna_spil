<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Egyptisk Kalaha - Nyt Spil</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            cursor: auto;
        }

        body {
            font-family: 'Papyrus', 'Copperplate', 'Trebuchet MS', system-ui, sans-serif;
            background-image: url('egyptian_background.jpeg');
            background-size: cover;
            background-attachment: fixed;
            background-position: center;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow-x: hidden;
        }

        .game-container {
            background:
                linear-gradient(180deg, rgba(255, 250, 235, 0.92) 0%, rgba(245, 228, 190, 0.92) 100%),
                repeating-linear-gradient(90deg, rgba(120, 86, 38, 0.035) 0px, rgba(120, 86, 38, 0.035) 2px, rgba(255, 255, 255, 0) 2px, rgba(255, 255, 255, 0) 10px),
                repeating-linear-gradient(0deg, rgba(120, 86, 38, 0.02) 0px, rgba(120, 86, 38, 0.02) 1px, rgba(255, 255, 255, 0) 1px, rgba(255, 255, 255, 0) 9px);
            border-radius: 30px;
            padding: 18px;
            max-width: 1400px;
            width: 100%;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.3);
            animation: containerFloat 3s ease-in-out infinite;
            border: 1px solid rgba(120, 86, 38, 0.25);
            backdrop-filter: blur(2px);
        }

        @keyframes containerFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        h1 {
            text-align: center;
            color: #1a5490;
            font-size: 2.5em;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
            animation: titlePulse 2s ease-in-out infinite;
        }

        @keyframes titlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        /* Start Screen */
        .start-screen {
            text-align: center;
            animation: fadeIn 0.8s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .game-modes {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .mode-card {
            background:
                linear-gradient(180deg, rgba(255, 250, 235, 0.95) 0%, rgba(242, 220, 175, 0.95) 100%),
                repeating-linear-gradient(90deg, rgba(120, 86, 38, 0.03) 0px, rgba(120, 86, 38, 0.03) 2px, rgba(255, 255, 255, 0) 2px, rgba(255, 255, 255, 0) 10px);
            border-radius: 20px;
            padding: 30px;
            min-width: 250px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            border: 3px solid transparent;
        }

        .mode-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.2);
            border-color: rgba(186, 140, 55, 0.9);
        }

        .mode-card.selected {
            border-color: rgba(186, 140, 55, 1);
            background:
                linear-gradient(180deg, rgba(255, 245, 220, 0.98) 0%, rgba(235, 205, 150, 0.98) 100%),
                repeating-linear-gradient(90deg, rgba(120, 86, 38, 0.04) 0px, rgba(120, 86, 38, 0.04) 2px, rgba(255, 255, 255, 0) 2px, rgba(255, 255, 255, 0) 10px);
            transform: scale(1.05);
        }

        .mode-icon {
            font-size: 3em;
            margin-bottom: 15px;
        }

        .mode-icon-img {
            width: 64px;
            height: 64px;
            border-radius: 16px;
            object-fit: cover;
            margin-bottom: 15px;
            border: 3px solid rgba(186, 140, 55, 0.75);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.18);
        }

        .mode-title {
            font-size: 1.5em;
            color: #1a5490;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .mode-description {
            color: #666;
            margin-bottom: 20px;
        }

        .avatar-selection {
            margin: 30px 0;
        }

        .avatar-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 15px;
            max-width: 600px;
            margin: 20px auto;
        }

        .avatar-option {
            width: 100px;
            height: 100px;
            border-radius: 15px;
            border: 3px solid transparent;
            cursor: pointer;
            transition: all 0.3s ease;
            object-fit: cover;
        }

        .avatar-option:hover {
            transform: scale(1.05) rotate(3deg);
            border-color: #1a5490;
            box-shadow: 0 8px 20px rgba(26, 84, 144, 0.3);
        }

        .avatar-option.selected {
            border-color: #e63946;
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(230, 57, 70, 0.5);
            animation: selectedPulse 1s ease-in-out infinite;
        }

        @keyframes selectedPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(230, 57, 70, 0.5); }
            50% { box-shadow: 0 0 30px rgba(230, 57, 70, 0.8); }
        }

        button {
            background: linear-gradient(135deg, #caa24a 0%, #8a5a13 100%);
            color: white;
            border: 1px solid rgba(120, 86, 38, 0.55);
            padding: 18px 50px;
            font-size: 1.3em;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
            box-shadow:
                0 10px 24px rgba(0, 0, 0, 0.22),
                inset 0 2px 0 rgba(255, 255, 255, 0.25);
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 240, 200, 0.38);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        button:hover::before {
            width: 300px;
            height: 300px;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow:
                0 14px 30px rgba(0, 0, 0, 0.28),
                0 0 18px rgba(202, 162, 74, 0.35);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Game Board */
        .game-screen {
            display: none;
            animation: gameScreenFade 0.5s ease-out;
        }

        @keyframes gameScreenFade {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 20px;
            background:
                linear-gradient(180deg, rgba(255, 250, 235, 0.92) 0%, rgba(240, 220, 175, 0.92) 100%),
                repeating-linear-gradient(90deg, rgba(120, 86, 38, 0.025) 0px, rgba(120, 86, 38, 0.025) 2px, rgba(255, 255, 255, 0) 2px, rgba(255, 255, 255, 0) 10px);
            border-radius: 15px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 1.2em;
        }

        .player-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid #1a5490;
            object-fit: cover;
        }

        .player-avatar.current {
            border-color: #e63946;
            animation: currentPlayerGlow 2s ease-in-out infinite;
        }

        @keyframes currentPlayerGlow {
            0%, 100% { box-shadow: 0 0 10px rgba(230, 57, 70, 0.5); }
            50% { box-shadow: 0 0 20px rgba(230, 57, 70, 0.8); }
        }

        .player-name {
            font-weight: bold;
            color: #1a5490;
        }

        .player-name.current {
            color: #e63946;
        }

        .player-score {
            background: #1a5490;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
        }

        .player-score.current {
            background: #e63946;
        }

        .game-board {
            background-image: url('kalaha_background_new.jpg');
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            border-radius: 20px;
            padding: 0;
            margin: 20px auto;
            box-shadow: inset 0 5px 15px rgba(0, 0, 0, 0.3);
            position: relative;
            width: 100%;
            max-width: min(1480px, 100%);
            aspect-ratio: 1024 / 682;
        }

        .game-board::before {
            content: '';
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 20px;
            pointer-events: none;
        }

        .board-overlay {
            position: relative;
            z-index: 1;
            width: 100%;
            height: 100%;
        }

        .store {
            position: absolute;
            width: 18%;
            height: 54%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 18px;
        }

        .store-label {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.9);
            font-weight: bold;
            margin-bottom: 5px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.6);
        }

        .store-stones {
            width: 100%;
            height: 70px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .stone-count {
            position: absolute;
            bottom: -10px;
            right: -10px;
            background: rgba(255, 255, 255, 0.95);
            color: #654321;
            border-radius: 999px;
            padding: 2px 8px;
            font-weight: bold;
            border: 2px solid rgba(0, 0, 0, 0.15);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            font-size: 0.9em;
        }

        .count-badge {
            position: absolute;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            color: #654321;
            border-radius: 999px;
            padding: 2px 8px;
            font-weight: bold;
            border: 2px solid rgba(0, 0, 0, 0.15);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            font-size: 0.9em;
            pointer-events: none;
            z-index: 5;
            user-select: none;
        }

        .pit {
            position: absolute;
            width: 7.6%;
            aspect-ratio: 1 / 1;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 0;
            background: transparent;
        }

        .pit:hover:not(.disabled) {
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
            background: rgba(255, 255, 255, 0.06);
        }

        .pit.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pit-stones {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .stone {
            width: 38px;
            height: 38px;
            object-fit: contain;
            position: absolute;
            transform: translate(-50%, -50%) rotate(var(--rot, 0deg));
            left: 50%;
            top: 50%;
            filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.4));
            user-select: none;
            pointer-events: none;
        }

        

        .stone.drop {
            animation: stoneDrop 260ms ease-out;
        }

        @keyframes stoneDrop {
            from { transform: translate(-50%, -65%) scale(1.15) rotate(var(--rot, 0deg)); opacity: 0.6; }
            to { transform: translate(-50%, -50%) scale(1) rotate(var(--rot, 0deg)); opacity: 1; }
        }

        .hand {
            position: absolute;
            left: -9999px;
            top: -9999px;
            width: 1px;
            height: 1px;
            overflow: hidden;
        }

        .pit.highlight {
            animation: pitHighlight 1s ease-in-out infinite;
        }

        .pit.sow-target,
        .store.sow-target {
            animation: sowTargetPulse 320ms ease-out;
            outline: 5px solid rgba(255, 215, 0, 0.95);
            box-shadow:
                0 0 0 4px rgba(255, 255, 255, 0.65),
                0 0 26px rgba(255, 215, 0, 0.95),
                0 10px 26px rgba(0, 0, 0, 0.25);
            background: rgba(255, 255, 255, 0.08);
        }

        @keyframes sowTargetPulse {
            from {
                transform: translate(-50%, -50%) scale(1.03);
                filter: brightness(1.12) saturate(1.1);
            }
            to {
                transform: translate(-50%, -50%) scale(1);
                filter: none;
            }
        }

        @keyframes pitHighlight {
            0%, 100% { 
                transform: scale(1); 
                box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            }
            50% { 
                transform: scale(1.05); 
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            }
        }

        .stone-animation {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #ffd700 0%, #ffb347 100%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .feedback {
            text-align: center;
            margin: 20px 0;
            font-size: 1.5em;
            font-weight: bold;
            min-height: 40px;
            animation: feedbackBounce 0.5s ease-out;
        }

        @keyframes feedbackBounce {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }

        .feedback.capture {
            color: #28a745;
        }

        .feedback.extra-turn {
            color: #ffc107;
        }

        .feedback.error {
            color: #dc3545;
        }

        /* Victory Screen */
        .victory-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .victory-message {
            background: white;
            border-radius: 30px;
            padding: 60px;
            text-align: center;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.3);
            animation: victoryBounce 0.8s ease-out;
            max-width: 500px;
        }

        @keyframes victoryBounce {
            0% { transform: scale(0.3) rotate(180deg); opacity: 0; }
            50% { transform: scale(1.05) rotate(90deg); opacity: 1; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        .victory-title {
            font-size: 3em;
            color: #1a5490;
            margin-bottom: 20px;
        }

        .victory-winner {
            font-size: 2em;
            color: #e63946;
            margin-bottom: 20px;
        }

        .victory-score {
            font-size: 1.5em;
            color: #666;
            margin-bottom: 30px;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .game-container {
                padding: 20px;
                margin: 10px;
            }

            h1 {
                font-size: 2em;
            }

            .game-modes {
                flex-direction: column;
                align-items: center;
            }

            .mode-card {
                min-width: 200px;
            }

            .pit {
                width: 60px;
                height: 60px;
            }

            .store {
                width: 80px;
                height: 100px;
            }

            .game-info {
                flex-direction: column;
                text-align: center;
            }
        }

        @media (max-width: 480px) {
            .pit {
                width: 50px;
                height: 50px;
            }

            .pit-stones {
                font-size: 1.2em;
            }

            .store {
                width: 70px;
                height: 80px;
            }

            .store-stones {
                font-size: 1.5em;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- Start Screen -->
        <div class="start-screen" id="startScreen">
            <h1>Egyptisk Kalaha</h1>
            
            <div class="game-modes">
                <div class="mode-card" onclick="selectMode('ai', this)" ontouchstart="selectMode('ai', this); return false;">
                    <img class="mode-icon-img" src="egypt_avatar_6.png" alt="Computer">
                    <div class="mode-title">Mod Computer</div>
                    <div class="mode-description">Spil mod en smart computermodstander</div>
                </div>
                
                <div class="mode-card" onclick="selectMode('human', this)" ontouchstart="selectMode('human', this); return false;">
                    <div class="mode-icon">üë•</div>
                    <div class="mode-title">2 Spillere</div>
                    <div class="mode-description">Spil mod en ven p√• samme enhed</div>
                </div>
            </div>

            <div class="avatar-selection" id="avatarSelection" style="display: none;">
                <h2>üéÆ V√¶lg din avatar:</h2>
                <div class="avatar-grid" id="avatarGrid"></div>
                
                <h2 id="player2AvatarTitle" style="display: none;">üéÆ Spiller 2 v√¶lger avatar:</h2>
                <div class="avatar-grid" id="player2AvatarGrid" style="display: none;"></div>
            </div>

            <button id="startButton" onclick="startGame()" disabled>Start Spil!</button>
        </div>

        <!-- Game Screen -->
        <div class="game-screen" id="gameScreen">
            <h1>Egyptisk Kalaha</h1>
            
            <div class="game-info" id="gameInfo"></div>
            
            <div class="feedback" id="feedback"></div>
            
            <div class="game-board">
                <div class="hand" id="hand"></div>
                <div class="board-overlay" id="boardOverlay">
                    <div class="store" id="player2Store" style="left: 16.568%; top: 46.75%;">
                        <div class="store-label">Spiller 2</div>
                        <div class="store-stones" data-store="2"></div>
                    </div>

                    <div class="store" id="player1Store" style="left: 82.267%; top: 46.064%;">
                        <div class="store-label">Spiller 1</div>
                        <div class="store-stones" data-store="1"></div>
                    </div>

                    <div class="count-badge" id="badge-storeL" style="left: 5.713%; top: 45.377%;">0</div>
                    <div class="count-badge" id="badge-storeR" style="left: 93.351%; top: 46.064%;">0</div>

                    <div class="count-badge" id="badge-top1" style="left: 28.794%; top: 25.648%;">0</div>
                    <div class="count-badge" id="badge-top2" style="left: 37.363%; top: 25.476%;">0</div>
                    <div class="count-badge" id="badge-top3" style="left: 45.247%; top: 25.305%;">0</div>
                    <div class="count-badge" id="badge-top4" style="left: 53.702%; top: 25.133%;">0</div>
                    <div class="count-badge" id="badge-top5" style="left: 62.043%; top: 24.962%;">0</div>
                    <div class="count-badge" id="badge-top6" style="left: 70.156%; top: 24.962%;">0</div>

                    <div class="count-badge" id="badge-bottom1" style="left: 27.879%; top: 65.107%;">0</div>
                    <div class="count-badge" id="badge-bottom2" style="left: 36.678%; top: 65.107%;">0</div>
                    <div class="count-badge" id="badge-bottom3" style="left: 45.133%; top: 65.45%;">0</div>
                    <div class="count-badge" id="badge-bottom4" style="left: 53.474%; top: 65.278%;">0</div>
                    <div class="count-badge" id="badge-bottom5" style="left: 62.043%; top: 65.278%;">0</div>
                    <div class="count-badge" id="badge-bottom6" style="left: 70.156%; top: 65.45%;">0</div>
                </div>
            </div>

            <div style="text-align: center;">
                <button onclick="restartGame()">Nyt Spil</button>
            </div>
        </div>

        <!-- Victory Screen -->
        <div class="victory-overlay" id="victoryOverlay">
            <div class="victory-message">
                <div class="victory-title">üèÜ Vinder! üèÜ</div>
                <div class="victory-winner" id="victoryWinner"></div>
                <div class="victory-score" id="victoryScore"></div>
                <button onclick="restartGame()">Spil Igen</button>
            </div>
        </div>
    </div>

    <script>
        // Game State
        let gameMode = null;
        let player1Avatar = null;
        let player2Avatar = null;
        let currentPlayer = 1;
        let board = [];
        let gameActive = false;
        let animating = false;
        let playerSkillLevel = 1; // 1-5 scale
        let gameHistory = [];
        let moveHistory = [];
        let gameStartTime = 0;

        const STONE_IMAGE_SRC = 'round_rock.png';
        const STONE_OFFSET_X_PX = 0;
        const STONE_OFFSET_Y_PX = 0;

        const SOW_STEP_MS = 650;
        const SOW_TARGET_PULSE_MS = 320;

        // Avatar Images
        const AVATAR_IMAGES = [
            'egypt_avatar_1.png',
            'egypt_avatar_2.png',
            'egypt_avatar_3.png',
            'egypt_avatar_4.png',
            'egypt_avatar_5.jpeg',
            'egypt_avatar_6.png'
        ];

        function pickDifferentAvatar(excludeSrc) {
            const pool = AVATAR_IMAGES.filter(a => a !== excludeSrc);
            if (pool.length === 0) return excludeSrc;
            return pool[Math.floor(Math.random() * pool.length)];
        }

        // Initialize Game
        function initGame() {
            createAvatarGrids();
            setupBoard();
        }

        function createAvatarGrids() {
            const grid1 = document.getElementById('avatarGrid');
            const grid2 = document.getElementById('player2AvatarGrid');
            
            grid1.innerHTML = '';
            grid2.innerHTML = '';
            
            AVATAR_IMAGES.forEach((imgSrc, index) => {
                // Player 1 avatars
                const img1 = document.createElement('img');
                img1.src = imgSrc;
                img1.className = 'avatar-option';
                img1.onclick = () => selectAvatar(1, imgSrc, img1);
                img1.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    selectAvatar(1, imgSrc, img1);
                }, { passive: false });
                grid1.appendChild(img1);
                
                // Player 2 avatars
                const img2 = document.createElement('img');
                img2.src = imgSrc;
                img2.className = 'avatar-option';
                img2.onclick = () => selectAvatar(2, imgSrc, img2);
                img2.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    selectAvatar(2, imgSrc, img2);
                }, { passive: false });
                grid2.appendChild(img2);
            });
        }

        function selectMode(mode, clickedCard) {
            gameMode = mode;
            
            // Update UI
            document.querySelectorAll('.mode-card').forEach(card => {
                card.classList.remove('selected');
            });
            if (clickedCard) {
                clickedCard.classList.add('selected');
            }
            
            // Show avatar selection
            document.getElementById('avatarSelection').style.display = 'block';
            
            if (mode === 'human') {
                document.getElementById('player2AvatarTitle').style.display = 'block';
                document.getElementById('player2AvatarGrid').style.display = 'grid';
            }
        }

        function selectAvatar(player, avatarSrc, element) {
            if (player === 1) {
                player1Avatar = avatarSrc;
                document.querySelectorAll('#avatarGrid .avatar-option').forEach(el => {
                    el.classList.remove('selected');
                });
            } else {
                player2Avatar = avatarSrc;
                document.querySelectorAll('#player2AvatarGrid .avatar-option').forEach(el => {
                    el.classList.remove('selected');
                });
            }
            
            element.classList.add('selected');
            checkReadyToStart();
        }

        function checkReadyToStart() {
            const ready = gameMode && player1Avatar && (gameMode === 'ai' || player2Avatar);
            document.getElementById('startButton').disabled = !ready;
        }

        function setupBoard() {
            // Initialize board with 6 stones in each pit
            board = [
                [0, 6, 6, 6, 6, 6, 6], // Player 1: [store, pit1, pit2, pit3, pit4, pit5, pit6]
                [0, 6, 6, 6, 6, 6, 6]  // Player 2: [store, pit1, pit2, pit3, pit4, pit5, pit6]
            ];
        }

        function loadPlayerData() {
            // Load skill level and game history from localStorage
            const savedData = localStorage.getItem('nannaKalahaData');
            if (savedData) {
                const data = JSON.parse(savedData);
                playerSkillLevel = data.skillLevel || 1;
                gameHistory = data.gameHistory || [];
            }
        }

        function savePlayerData() {
            // Save skill level and game history to localStorage
            const data = {
                skillLevel: playerSkillLevel,
                gameHistory: gameHistory.slice(-20) // Keep last 20 games
            };
            localStorage.setItem('nannaKalahaData', JSON.stringify(data));
        }

        function evaluatePlayerPerformance() {
            if (gameMode !== 'ai' || moveHistory.length === 0) return;

            const gameTime = Date.now() - gameStartTime;
            const playerScore = board[0][0];
            const aiScore = board[1][0];
            const won = playerScore > aiScore;
            
            // Calculate performance metrics
            const performance = {
                won: won,
                scoreDifference: playerScore - aiScore,
                moveCount: moveHistory.length,
                gameTime: gameTime,
                efficiency: playerScore / moveHistory.length,
                date: new Date().toISOString()
            };

            // Add to history
            gameHistory.push(performance);
            
            // Update skill level based on recent performance
            updateSkillLevel(performance);
            
            // Save data
            savePlayerData();
            
            // Show feedback to Nanna
            showSkillFeedback(performance);
        }

        function updateSkillLevel(performance) {
            // Consider last 5 games for skill evaluation
            const recentGames = gameHistory.slice(-5);
            if (recentGames.length < 3) return; // Need at least 3 games to evaluate

            const winRate = recentGames.filter(g => g.won).length / recentGames.length;
            const avgEfficiency = recentGames.reduce((sum, g) => sum + g.efficiency, 0) / recentGames.length;
            
            // Adjust skill level based on performance
            if (winRate >= 0.8 && avgEfficiency > 2.5) {
                // Winning most games with good efficiency - increase difficulty
                playerSkillLevel = Math.min(5, playerSkillLevel + 1);
                showFeedback('Du spiller fantastisk! Sv√¶rhedsgrad √∏get! üåü', 'extra-turn');
            } else if (winRate <= 0.2 && avgEfficiency < 1.5) {
                // Struggling - decrease difficulty
                playerSkillLevel = Math.max(1, playerSkillLevel - 1);
                showFeedback('Lad os g√∏re det lidt nemmere! üí™', 'extra-turn');
            }
        }

        function showSkillFeedback(performance) {
            let feedback = '';
            if (performance.won) {
                if (performance.scoreDifference > 20) {
                    feedback = 'üèÜ Fantastisk sejr! Du er virkelig god til dette!';
                } else if (performance.scoreDifference > 10) {
                    feedback = 'üéâ Godt spillet! Du vandt med solid margin!';
                } else {
                    feedback = 'üëè Tillykke med sejren! T√¶t kamp!';
                }
            } else {
                if (performance.scoreDifference < -20) {
                    feedback = 'üí™ Godt fors√∏g! Computeren var st√¶rk i dag. Pr√∏v igen!';
                } else if (performance.scoreDifference < -10) {
                    feedback = 'üéØ T√¶t kamp! Du var t√¶t p√• at vinde!';
                } else {
                    feedback = 'ü§ù Uafgjort! I er j√¶vnbyrdige!';
                }
            }
            
            // Add skill level info
            feedback += `\nDin niveau: ${'‚≠ê'.repeat(playerSkillLevel)}`;
            
            setTimeout(() => {
                showFeedback(feedback, performance.won ? 'capture' : 'extra-turn');
            }, 1000);
        }

        function startGame() {
            // Hide start screen, show game screen
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            
            // Set player 2 avatar for AI mode
            if (gameMode === 'ai') {
                player2Avatar = pickDifferentAvatar(player1Avatar);
            }
            
            // Initialize game
            currentPlayer = 1;
            gameActive = true;
            animating = false;
            moveHistory = [];
            gameStartTime = Date.now();
            setupBoard();
            syncBoardToDom(true);
            updateGameInfo();
            
            // Show skill level for AI mode
            if (gameMode === 'ai') {
                showFeedback(`Spiller mod Computer (Niveau ${'‚≠ê'.repeat(playerSkillLevel)})`, 'extra-turn');
            } else {
                showFeedback('Spiller 1 starter!', 'extra-turn');
            }
        }

        function updateDisplay() {
            syncBoardToDom(false);
        }

        function getPitElement(player, pitIndex) {
            return document.getElementById(`pit${player}-${pitIndex}`);
        }

        function getStoreContainer(player) {
            return document.querySelector(`[data-store="${player}"]`);
        }

        function createStoneElement() {
            const img = document.createElement('img');
            img.src = STONE_IMAGE_SRC;
            img.className = 'stone';
            return img;
        }

        function pulseSowTarget(el) {
            if (!el) return;
            el.classList.remove('sow-target');
            void el.offsetWidth;
            el.classList.add('sow-target');
            setTimeout(() => el.classList.remove('sow-target'), SOW_TARGET_PULSE_MS);
        }

        function getNextSowPosition(player, currentRow, currentPit) {
            // Pits are numbered 1..6 where pit1 is closest to the player's store.
            // Sowing direction for both players is toward pit1, then (only for own row) into store.
            // Sequence example (player 1): 4 -> 3 -> 2 -> 1 -> store -> opponent 6 -> ... -> 1 -> back to own 6...
            if (currentPit === 0) {
                // We were at the store; continue on the opponent side at pit6
                return { row: currentRow === 1 ? 2 : 1, pit: 6, isStore: false };
            }
            if (currentPit > 1) {
                return { row: currentRow, pit: currentPit - 1, isStore: false };
            }

            // currentPit === 1
            if (currentRow === player) {
                return { row: currentRow, pit: 0, isStore: true };
            }

            // Opponent pit1 -> jump to player's pit6
            return { row: currentRow === 1 ? 2 : 1, pit: 6, isStore: false };
        }

        function pickUpStonesFromPit(player, pitIndex) {
            const hand = document.getElementById('hand');
            const pitEl = getPitElement(player, pitIndex);
            const container = pitEl ? pitEl.querySelector('.pit-stones') : null;
            const picked = [];
            if (!container) return picked;
            container.querySelectorAll('img.stone').forEach(st => {
                picked.push(st);
                hand.appendChild(st);
            });
            setStoneCountBadge(container, 0);
            setPitCountBadge(player, pitIndex, 0);
            return picked;
        }

        function randomStonePosition(el, countInContainer, containerOverride) {
            const container = containerOverride || el.parentElement;
            const w = container ? container.clientWidth : 80;
            const h = container ? container.clientHeight : 80;
            const stoneSize = parseFloat(getComputedStyle(el).width) || 30;
            const maxRadius = Math.max(4, Math.min(w, h) / 2 - stoneSize / 2 - 2);
            const densityRadius = countInContainer <= 2 ? maxRadius * 0.35 : countInContainer <= 6 ? maxRadius * 0.55 : maxRadius * 0.75;
            const angle = Math.random() * Math.PI * 2;
            const r = Math.random() * densityRadius;
            const x = w / 2 + Math.cos(angle) * r + STONE_OFFSET_X_PX;
            const y = h / 2 + Math.sin(angle) * r + STONE_OFFSET_Y_PX;
            const rot = (Math.random() * 50 - 25).toFixed(1);
            el.style.left = `${x}px`;
            el.style.top = `${y}px`;
            el.style.setProperty('--rot', `${rot}deg`);
        }

        function setStoneCountBadge(container, count) {
            // Deprecated: counts are now shown using fixed-position badges on the board.
        }

        function setCountBadgeById(id, count) {
            const el = document.getElementById(id);
            if (el) el.textContent = String(count);
        }

        function setPitCountBadge(player, pitIndex, count) {
            // Player 2 pits are the top row, player 1 pits are the bottom row
            if (player === 2) {
                setCountBadgeById(`badge-top${pitIndex}`, count);
            } else {
                // bottom badges are labeled bottom1..bottom6 left->right;
                // but player 1 pitIndex is reversed (6..1 left->right)
                const pos = 7 - pitIndex;
                setCountBadgeById(`badge-bottom${pos}`, count);
            }
        }

        function setStoreCountBadges() {
            // Left store is player2, right store is player1
            setCountBadgeById('badge-storeL', board[1][0]);
            setCountBadgeById('badge-storeR', board[0][0]);
        }

        function renderContainerStones(container, count, maxRendered) {
            container.querySelectorAll('img.stone').forEach(n => n.remove());
            const toRender = Math.min(count, maxRendered);
            for (let i = 0; i < toRender; i++) {
                const stone = createStoneElement();
                container.appendChild(stone);
                randomStonePosition(stone, toRender, container);
            }
        }

        function syncBoardToDom(forceFullRender) {
            // Pits
            for (let i = 1; i <= 6; i++) {
                const pit1 = getPitElement(1, i);
                const pit2 = getPitElement(2, i);
                if (pit1) {
                    renderContainerStones(pit1.querySelector('.pit-stones'), board[0][i], 12);
                    setPitCountBadge(1, i, board[0][i]);
                }
                if (pit2) {
                    renderContainerStones(pit2.querySelector('.pit-stones'), board[1][i], 12);
                    setPitCountBadge(2, i, board[1][i]);
                }
            }

            // Stores (render fewer stones so it stays fast)
            const store1 = getStoreContainer(1);
            const store2 = getStoreContainer(2);
            if (store1) renderContainerStones(store1, board[0][0], 16);
            if (store2) renderContainerStones(store2, board[1][0], 16);

            setStoreCountBadges();
        }

        function updateGameInfo() {
            const gameInfo = document.getElementById('gameInfo');
            
            const player1Name = gameMode === 'ai' ? 'Dig' : 'Spiller 1';
            const player2Name = gameMode === 'ai' ? 'Computer' : 'Spiller 2';
            
            gameInfo.innerHTML = `
                <div class="player-info">
                    <img src="${player1Avatar}" class="player-avatar ${currentPlayer === 1 ? 'current' : ''}">
                    <div>
                        <div class="player-name ${currentPlayer === 1 ? 'current' : ''}">${player1Name}</div>
                        <div class="player-score ${currentPlayer === 1 ? 'current' : ''}">Point: ${board[0][0]}</div>
                    </div>
                </div>
                <div class="player-info">
                    <div>
                        <div class="player-name ${currentPlayer === 2 ? 'current' : ''}">${player2Name}</div>
                        <div class="player-score ${currentPlayer === 2 ? 'current' : ''}">Point: ${board[1][0]}</div>
                    </div>
                    <img src="${player2Avatar}" class="player-avatar ${currentPlayer === 2 ? 'current' : ''}">
                </div>
            `;
        }

        function createPits() {
            const overlay = document.getElementById('boardOverlay');
            if (!overlay) return;

            overlay.querySelectorAll('.pit').forEach(p => p.remove());

            // These coordinates come from Games/Kalaha/alignment_helper.html
            const TOP = [
                { x: 28.908, y: 34.569 },
                { x: 37.249, y: 34.398 },
                { x: 45.476, y: 34.398 },
                { x: 53.702, y: 34.226 },
                { x: 61.929, y: 34.226 },
                { x: 70.156, y: 34.226 }
            ];
            const BOTTOM = [
                { x: 28.908, y: 52.926 },
                { x: 37.477, y: 53.097 },
                { x: 45.361, y: 52.926 },
                { x: 53.702, y: 52.926 },
                { x: 62.043, y: 52.926 },
                { x: 70.27, y: 52.926 }
            ];

            // Player 2 pits (top row): left->right indexes 1..6
            for (let i = 1; i <= 6; i++) {
                const pit = document.createElement('div');
                pit.className = 'pit top-row';
                pit.id = `pit2-${i}`;
                pit.dataset.player = '2';
                pit.dataset.pitIndex = String(i);
                pit.style.left = `${TOP[i - 1].x}%`;
                pit.style.top = `${TOP[i - 1].y}%`;
                pit.innerHTML = `<div class="pit-stones"></div>`;
                pit.onclick = () => makeMove(2, i);
                overlay.appendChild(pit);
            }

            // Player 1 pits (bottom row): left->right indexes 6..1 (so pit1 is closest to player1 store)
            for (let pos = 0; pos < 6; pos++) {
                const pitIndex = 6 - pos;
                const pit = document.createElement('div');
                pit.className = 'pit bottom-row';
                pit.id = `pit1-${pitIndex}`;
                pit.dataset.player = '1';
                pit.dataset.pitIndex = String(pitIndex);
                pit.style.left = `${BOTTOM[pos].x}%`;
                pit.style.top = `${BOTTOM[pos].y}%`;
                pit.innerHTML = `<div class="pit-stones"></div>`;
                pit.onclick = () => makeMove(1, pitIndex);
                overlay.appendChild(pit);
            }

            syncBoardToDom(true);
        }

        function makeMove(player, pitIndex) {
            if (!gameActive || animating || player !== currentPlayer) return;
            if (board[player - 1][pitIndex] === 0) {
                showFeedback('Denne br√∏nd er tom!', 'error');
                return;
            }
            
            // Get stones from the pit
            const stones = board[player - 1][pitIndex];
            board[player - 1][pitIndex] = 0;
            
            // Animate the move
            animateMove(player, pitIndex, stones);
        }

        function animateMove(player, startPit, stones) {
            animating = true;
            let currentStones = stones;
            let currentPit = startPit;
            let currentRow = player;

            const picked = pickUpStonesFromPit(player, startPit);

            let lastLandingRow = player;
            let lastLandingPit = startPit;
            let lastLandingWasStore = false;
            
            // Animation interval
            const interval = setInterval(() => {
                if (currentStones === 0) {
                    clearInterval(interval);
                    finishMove(player, lastLandingRow, lastLandingPit, lastLandingWasStore);
                    return;
                }
                
                // Move to next position
                const next = getNextSowPosition(player, currentRow, currentPit);
                currentRow = next.row;
                currentPit = next.pit;

                if (next.isStore) {
                    board[currentRow - 1][0]++;
                    const store = getStoreContainer(player);
                    if (store) {
                        pulseSowTarget(store.closest('.store'));
                        const stoneEl = picked.pop() || createStoneElement();
                        stoneEl.classList.remove('drop');
                        void stoneEl.offsetWidth;
                        stoneEl.classList.add('drop');
                        store.appendChild(stoneEl);
                        randomStonePosition(stoneEl, Math.min(board[player - 1][0], 16), store);
                        setStoneCountBadge(store, board[player - 1][0]);
                    }

                    setStoreCountBadges();

                    lastLandingRow = currentRow;
                    lastLandingPit = 0;
                    lastLandingWasStore = true;
                } else {
                    board[currentRow - 1][currentPit]++;
                    const destPit = getPitElement(currentRow, currentPit);
                    const destContainer = destPit ? destPit.querySelector('.pit-stones') : null;
                    if (destContainer) {
                        pulseSowTarget(destPit);
                        const stoneEl = picked.pop() || createStoneElement();
                        stoneEl.classList.remove('drop');
                        void stoneEl.offsetWidth;
                        stoneEl.classList.add('drop');
                        destContainer.appendChild(stoneEl);
                        randomStonePosition(stoneEl, Math.min(board[currentRow - 1][currentPit], 12), destContainer);
                        setStoneCountBadge(destContainer, board[currentRow - 1][currentPit]);
                    }

                    setPitCountBadge(currentRow, currentPit, board[currentRow - 1][currentPit]);

                    lastLandingRow = currentRow;
                    lastLandingPit = currentPit;
                    lastLandingWasStore = false;
                }
                
                currentStones--;
            }, SOW_STEP_MS);
        }

        function finishMove(player, lastRow, lastPit, lastWasStore) {
            // With simplified rules: continue sowing until you hit an empty pit
            // The last pit determines what happens next

            if (lastWasStore) {
                // Landed in store - extra turn!
                showFeedback('Ekstra tur!', 'extra-turn');
                updateGameInfo();
                animating = false;

                // If AI earned an extra turn, take it automatically
                if (gameMode === 'ai' && currentPlayer === 2) {
                    setTimeout(() => makeAIMove(), 900);
                }
                return;
            }
            
            // Avalanche rule: continue only if the last pit was NOT empty before the last stone dropped.
            // After dropping a stone, an originally-empty pit will have exactly 1 stone.
            if (board[lastRow - 1][lastPit] > 1) {
                showFeedback('Forts√¶tter med at s√•!', 'extra-turn');
                
                // Pick up stones from last pit and continue sowing
                const continueStones = board[lastRow - 1][lastPit];
                board[lastRow - 1][lastPit] = 0;
                const picked = pickUpStonesFromPit(lastRow, lastPit);
                
                // Continue sowing from this position
                setTimeout(() => {
                    animateContinueMove(player, lastRow, lastPit, continueStones, picked);
                }, 500);
                return;
            }
            
            // Landed in empty pit - turn ends
            showFeedback('Tur slut', 'capture');
            
            // Switch player
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            updateGameInfo();
            
            // Check for game end
            if (checkGameEnd()) {
                endGame();
                return;
            }
            
            // AI move
            if (gameMode === 'ai' && currentPlayer === 2) {
                animating = false;
                setTimeout(() => makeAIMove(), 1000);
            } else {
                animating = false;
            }
        }

        function animateContinueMove(mover, startRow, startPit, stones, picked) {
            let currentStones = stones;
            let currentPit = startPit;
            let currentRow = startRow;

            let lastLandingRow = startRow;
            let lastLandingPit = startPit;
            let lastLandingWasStore = false;
            
            // Animation interval
            const interval = setInterval(() => {
                if (currentStones === 0) {
                    clearInterval(interval);
                    finishMove(mover, lastLandingRow, lastLandingPit, lastLandingWasStore);
                    return;
                }
                
                // Move to next position
                const next = getNextSowPosition(mover, currentRow, currentPit);
                currentRow = next.row;
                currentPit = next.pit;

                if (next.isStore) {
                    board[currentRow - 1][0]++;
                    const store = getStoreContainer(mover);
                    if (store) {
                        pulseSowTarget(store.closest('.store'));
                        const stoneEl = (picked && picked.pop()) || createStoneElement();
                        stoneEl.classList.remove('drop');
                        void stoneEl.offsetWidth;
                        stoneEl.classList.add('drop');
                        store.appendChild(stoneEl);
                        randomStonePosition(stoneEl, Math.min(board[mover - 1][0], 16), store);
                        setStoneCountBadge(store, board[mover - 1][0]);
                    }

                    setStoreCountBadges();

                    lastLandingRow = currentRow;
                    lastLandingPit = 0;
                    lastLandingWasStore = true;
                } else {
                    board[currentRow - 1][currentPit]++;
                    const destPit = getPitElement(currentRow, currentPit);
                    const destContainer = destPit ? destPit.querySelector('.pit-stones') : null;
                    if (destContainer) {
                        pulseSowTarget(destPit);
                        const stoneEl = (picked && picked.pop()) || createStoneElement();
                        stoneEl.classList.remove('drop');
                        void stoneEl.offsetWidth;
                        stoneEl.classList.add('drop');
                        destContainer.appendChild(stoneEl);
                        randomStonePosition(stoneEl, Math.min(board[currentRow - 1][currentPit], 12), destContainer);
                        setStoneCountBadge(destContainer, board[currentRow - 1][currentPit]);
                    }

                    setPitCountBadge(currentRow, currentPit, board[currentRow - 1][currentPit]);

                    lastLandingRow = currentRow;
                    lastLandingPit = currentPit;
                    lastLandingWasStore = false;
                }
                
                currentStones--;
            }, SOW_STEP_MS);
        }

        function makeAIMove() {
            showFeedback('Computeren t√¶nker...', 'extra-turn');
            
            setTimeout(() => {
                const bestMove = calculateBestMove();
                if (bestMove !== -1) {
                    makeMove(2, bestMove);
                }
            }, 1000);
        }

        function calculateBestMove() {
            const validPits = [];
            for (let i = 1; i <= 6; i++) {
                if (board[1][i] > 0) {
                    validPits.push(i);
                }
            }
            
            if (validPits.length === 0) return -1;

            const getValidPitsForBoard = (b, player) => {
                const idx = player - 1;
                const pits = [];
                for (let i = 1; i <= 6; i++) {
                    if (b[idx][i] > 0) pits.push(i);
                }
                return pits;
            };

            const pickBestMoveForBoard = (b, player) => {
                const pits = getValidPitsForBoard(b, player);
                if (pits.length === 0) return { pit: -1, score: -Infinity };

                let best = { pit: pits[0], score: -Infinity };
                for (const pit of pits) {
                    const { board: nextBoard, extraTurn } = simulateAvalancheMove(b, player, pit);
                    let s = evaluateBoardForPlayer(nextBoard, player);
                    if (extraTurn) s += 40;
                    if (s > best.score) best = { pit, score: s };
                }
                return best;
            };
            
            // Adjust AI behavior based on skill level
            let bestMove = -1;
            let bestScore = -1;
            
            for (const pit of validPits) {
                let score = 0;

                const baseBoard = [
                    [...board[0]],
                    [...board[1]]
                ];

                const sim = simulateAvalancheMove(baseBoard, 2, pit);
                score += evaluateBoardForPlayer(sim.board, 2);
                if (sim.extraTurn) score += 50;

                // Skill level adjustments
                switch(playerSkillLevel) {
                    case 1: // Beginner - AI makes some mistakes
                        // 30% chance to make a random move instead
                        if (Math.random() < 0.3) {
                            score = Math.random() * 50;
                        }
                        break;
                        
                    case 2: // Easy - Basic strategy with some randomness
                        // 20% chance to make a random move
                        if (Math.random() < 0.2) {
                            score = Math.random() * 70;
                        }
                        // Light penalty for leaving opponent a strong immediate move
                        {
                            const oppBest = pickBestMoveForBoard(sim.board, 1);
                            score -= Math.max(0, oppBest.score) * 0.15;
                        }
                        break;
                        
                    case 3: // Medium - Balanced strategy
                        // 10% chance to make a random move
                        if (Math.random() < 0.1) {
                            score = Math.random() * 90;
                        }
                        // 1-ply lookahead: assume opponent plays best immediate response
                        {
                            const opp = pickBestMoveForBoard(sim.board, 1);
                            score -= Math.max(0, opp.score) * 0.35;
                        }
                        break;
                        
                    case 4: // Hard - Strong strategy
                        // 5% chance to make a random move
                        if (Math.random() < 0.05) {
                            score = Math.random() * 95;
                        }
                        // 1-ply lookahead with stronger penalty
                        {
                            const opp = pickBestMoveForBoard(sim.board, 1);
                            score -= Math.max(0, opp.score) * 0.55;
                        }
                        break;
                        
                    case 5: // Expert - Optimal play
                        // Very little randomness
                        if (Math.random() < 0.02) {
                            score = Math.random() * 98;
                        }
                        // 2-ply lookahead: opponent best response, then AI best reply
                        {
                            const opp = pickBestMoveForBoard(sim.board, 1);
                            if (opp.pit !== -1) {
                                const afterOpp = simulateAvalancheMove(sim.board, 1, opp.pit);
                                const reply = pickBestMoveForBoard(afterOpp.board, 2);
                                score = score - Math.max(0, opp.score) * 0.75 + Math.max(0, reply.score) * 0.25;
                            } else {
                                score += 15;
                            }
                        }
                        break;
                }
                
                // Add small randomness to all levels
                score += Math.random() * 5;
                
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = pit;
                }
            }
            
            return bestMove;
        }

        function simulateMove(player, pitIndex) {
            // Create a copy of the board for simulation
            const simBoard = [
                [...board[0]],
                [...board[1]]
            ];
            
            const result = simulateAvalancheMove(simBoard, player, pitIndex);
            return result.board;
        }

        function simulateAvalancheMove(boardState, player, pitIndex) {
            // Returns { board, extraTurn }
            // Uses the same sowing stepper + avalanche continuation as the real game.
            const b = [
                [...boardState[0]],
                [...boardState[1]]
            ];

            const pIdx = player - 1;
            let stones = b[pIdx][pitIndex];
            b[pIdx][pitIndex] = 0;

            let currentRow = player;
            let currentPit = pitIndex;
            let lastRow = player;
            let lastPit = pitIndex;
            let lastWasStore = false;

            const sowOnce = (startRow, startPit, s) => {
                let row = startRow;
                let pit = startPit;
                let last = { row: startRow, pit: startPit, wasStore: false };
                while (s > 0) {
                    const next = getNextSowPosition(player, row, pit);
                    row = next.row;
                    pit = next.pit;
                    if (next.isStore) {
                        b[row - 1][0]++;
                        last = { row, pit: 0, wasStore: true };
                    } else {
                        b[row - 1][pit]++;
                        last = { row, pit, wasStore: false };
                    }
                    s--;
                }
                return last;
            };

            while (stones > 0) {
                const last = sowOnce(currentRow, currentPit, stones);
                lastRow = last.row;
                lastPit = last.pit;
                lastWasStore = last.wasStore;

                if (lastWasStore) {
                    return { board: b, extraTurn: true };
                }

                // Avalanche: continue only if last pit was non-empty before the drop (i.e. now > 1)
                if (b[lastRow - 1][lastPit] <= 1) {
                    return { board: b, extraTurn: false };
                }

                stones = b[lastRow - 1][lastPit];
                b[lastRow - 1][lastPit] = 0;
                currentRow = lastRow;
                currentPit = lastPit;
            }

            return { board: b, extraTurn: false };
        }

        function evaluateBoardForPlayer(boardState, player) {
            // Evaluate how good a board position is for a player
            let score = 0;
            const idx = player - 1;
            const opp = idx === 0 ? 1 : 0;
            
            // Store stones are most valuable
            score += boardState[idx][0] * 10;
            score -= boardState[opp][0] * 10;
            
            // Stones in pits are valuable based on position
            for (let i = 1; i <= 6; i++) {
                // Pits closer to store are slightly more valuable
                const positionBonus = Math.abs(i - 4) * 0.5;
                score += boardState[idx][i] * (1 + positionBonus);
                score -= boardState[opp][i] * (1 + positionBonus) * 0.9;
            }
            
            return score;
        }

        function checkGameEnd() {
            // Check if one player's pits are all empty
            const player1Empty = board[0].slice(1).every(stones => stones === 0);
            const player2Empty = board[1].slice(1).every(stones => stones === 0);
            
            return player1Empty || player2Empty;
        }

        function endGame() {
            gameActive = false;
            
            // Collect remaining stones
            for (let player = 1; player <= 2; player++) {
                for (let pit = 1; pit <= 6; pit++) {
                    board[player - 1][0] += board[player - 1][pit];
                    board[player - 1][pit] = 0;
                }
            }
            
            updateDisplay();
            
            // Evaluate performance and update skill level
            evaluatePlayerPerformance();
            
            // Determine winner
            const player1Score = board[0][0];
            const player2Score = board[1][0];
            
            let winner, winnerText;
            if (player1Score > player2Score) {
                winner = 1;
                winnerText = gameMode === 'ai' ? 'Du vandt!' : 'Spiller 1 vandt!';
            } else if (player2Score > player1Score) {
                winner = 2;
                winnerText = gameMode === 'ai' ? 'Computeren vandt!' : 'Spiller 2 vandt!';
            } else {
                winnerText = 'Uafgjort!';
            }
            
            // Show victory screen
            document.getElementById('victoryWinner').textContent = winnerText;
            document.getElementById('victoryScore').textContent = 
                `Spiller 1: ${player1Score} | ${gameMode === 'ai' ? 'Computer' : 'Spiller 2'}: ${player2Score}`;
            document.getElementById('victoryOverlay').style.display = 'flex';
        }

        function showFeedback(message, type) {
            const feedback = document.getElementById('feedback');
            feedback.textContent = message;
            feedback.className = `feedback ${type}`;
            
            setTimeout(() => {
                feedback.textContent = '';
                feedback.className = 'feedback';
            }, 2000);
        }

        function restartGame() {
            document.getElementById('victoryOverlay').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'block';
            
            // Reset selections
            gameMode = null;
            player1Avatar = null;
            player2Avatar = null;
            document.getElementById('startButton').disabled = true;
            document.querySelectorAll('.mode-card').forEach(card => {
                card.classList.remove('selected');
            });
            document.querySelectorAll('.avatar-option').forEach(el => {
                el.classList.remove('selected');
            });
            
            if (gameMode === 'human') {
                document.getElementById('player2AvatarTitle').style.display = 'none';
                document.getElementById('player2AvatarGrid').style.display = 'none';
            }
        }

        // Initialize on load
        window.onload = () => {
            loadPlayerData(); // Load saved skill level and history
            initGame();
            createPits();
        };
    </script>
</body>
</html>
