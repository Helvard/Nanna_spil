<!DOCTYPE html>
<html lang="da">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üêæ Paw Patrol Kalaha - Nyt Spil</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            cursor: url('../../paw_patrol/cursor_badge.jpeg'), auto;
        }

        body {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background-image: url('../../paw_patrol/Adventure_Bay_%28S3%29.webp');
            background-size: cover;
            background-attachment: fixed;
            background-position: center;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow-x: hidden;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 30px;
            padding: 30px;
            max-width: 1200px;
            width: 100%;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.3);
            animation: containerFloat 3s ease-in-out infinite;
        }

        @keyframes containerFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        h1 {
            text-align: center;
            color: #1a5490;
            font-size: 2.5em;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
            animation: titlePulse 2s ease-in-out infinite;
        }

        @keyframes titlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        /* Start Screen */
        .start-screen {
            text-align: center;
            animation: fadeIn 0.8s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .game-modes {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .mode-card {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 20px;
            padding: 30px;
            min-width: 250px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            border: 3px solid transparent;
        }

        .mode-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.2);
            border-color: #1a5490;
        }

        .mode-card.selected {
            border-color: #e63946;
            background: linear-gradient(135deg, #fff5f5 0%, #ffe3e3 100%);
            transform: scale(1.05);
        }

        .mode-icon {
            font-size: 3em;
            margin-bottom: 15px;
        }

        .mode-title {
            font-size: 1.5em;
            color: #1a5490;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .mode-description {
            color: #666;
            margin-bottom: 20px;
        }

        .avatar-selection {
            margin: 30px 0;
        }

        .avatar-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 15px;
            max-width: 600px;
            margin: 20px auto;
        }

        .avatar-option {
            width: 100px;
            height: 100px;
            border-radius: 15px;
            border: 3px solid transparent;
            cursor: pointer;
            transition: all 0.3s ease;
            object-fit: cover;
        }

        .avatar-option:hover {
            transform: scale(1.05) rotate(3deg);
            border-color: #1a5490;
            box-shadow: 0 8px 20px rgba(26, 84, 144, 0.3);
        }

        .avatar-option.selected {
            border-color: #e63946;
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(230, 57, 70, 0.5);
            animation: selectedPulse 1s ease-in-out infinite;
        }

        @keyframes selectedPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(230, 57, 70, 0.5); }
            50% { box-shadow: 0 0 30px rgba(230, 57, 70, 0.8); }
        }

        button {
            background: linear-gradient(135deg, #1a5490 0%, #0d3a6b 100%);
            color: white;
            border: none;
            padding: 18px 50px;
            font-size: 1.3em;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            box-shadow: 0 6px 20px rgba(26, 84, 144, 0.3);
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        button:hover::before {
            width: 300px;
            height: 300px;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(26, 84, 144, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Game Board */
        .game-screen {
            display: none;
            animation: gameScreenFade 0.5s ease-out;
        }

        @keyframes gameScreenFade {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 20px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 15px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 1.2em;
        }

        .player-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid #1a5490;
            object-fit: cover;
        }

        .player-avatar.current {
            border-color: #e63946;
            animation: currentPlayerGlow 2s ease-in-out infinite;
        }

        @keyframes currentPlayerGlow {
            0%, 100% { box-shadow: 0 0 10px rgba(230, 57, 70, 0.5); }
            50% { box-shadow: 0 0 20px rgba(230, 57, 70, 0.8); }
        }

        .player-name {
            font-weight: bold;
            color: #1a5490;
        }

        .player-name.current {
            color: #e63946;
        }

        .player-score {
            background: #1a5490;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
        }

        .player-score.current {
            background: #e63946;
        }

        .game-board {
            background-image: url('kalaha_background_new.jpg');
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            border-radius: 20px;
            padding: 0;
            margin: 20px 0;
            box-shadow: inset 0 5px 15px rgba(0, 0, 0, 0.3);
            position: relative;
            width: 100%;
            max-width: 1024px;
            aspect-ratio: 1024 / 682;
        }

        .game-board::before {
            content: '';
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 20px;
            pointer-events: none;
        }

        .board-overlay {
            position: relative;
            z-index: 1;
            width: 100%;
            height: 100%;
        }

        .store {
            position: absolute;
            width: 16%;
            height: 62%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 18px;
        }

        .store-label {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.9);
            font-weight: bold;
            margin-bottom: 5px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.6);
        }

        .store-stones {
            width: 100%;
            height: 70px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .stone-count {
            position: absolute;
            bottom: -10px;
            right: -10px;
            background: rgba(255, 255, 255, 0.95);
            color: #654321;
            border-radius: 999px;
            padding: 2px 8px;
            font-weight: bold;
            border: 2px solid rgba(0, 0, 0, 0.15);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            font-size: 0.9em;
        }

        .pit {
            position: absolute;
            width: 9.5%;
            aspect-ratio: 1 / 1;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.15);
            background: rgba(0, 0, 0, 0.08);
            backdrop-filter: blur(1px);
        }

        .pit:hover:not(.disabled) {
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
            background: rgba(255, 255, 255, 0.10);
        }

        .pit.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pit-stones {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .stone {
            width: 22px;
            height: 22px;
            object-fit: contain;
            position: absolute;
            transform: translate(-50%, -50%) rotate(var(--rot, 0deg));
            left: var(--x, 50%);
            top: var(--y, 50%);
            filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.4));
            user-select: none;
            pointer-events: none;
        }

        .stone.drop {
            animation: stoneDrop 180ms ease-out;
        }

        @keyframes stoneDrop {
            from { transform: translate(-50%, -65%) scale(1.15) rotate(var(--rot, 0deg)); opacity: 0.6; }
            to { transform: translate(-50%, -50%) scale(1) rotate(var(--rot, 0deg)); opacity: 1; }
        }

        .hand {
            position: absolute;
            left: -9999px;
            top: -9999px;
            width: 1px;
            height: 1px;
            overflow: hidden;
        }

        .pit.highlight {
            animation: pitHighlight 1s ease-in-out infinite;
        }

        @keyframes pitHighlight {
            0%, 100% { 
                transform: scale(1); 
                box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            }
            50% { 
                transform: scale(1.05); 
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            }
        }

        .stone-animation {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #ffd700 0%, #ffb347 100%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .feedback {
            text-align: center;
            margin: 20px 0;
            font-size: 1.5em;
            font-weight: bold;
            min-height: 40px;
            animation: feedbackBounce 0.5s ease-out;
        }

        @keyframes feedbackBounce {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }

        .feedback.capture {
            color: #28a745;
        }

        .feedback.extra-turn {
            color: #ffc107;
        }

        .feedback.error {
            color: #dc3545;
        }

        /* Victory Screen */
        .victory-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .victory-message {
            background: white;
            border-radius: 30px;
            padding: 60px;
            text-align: center;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.3);
            animation: victoryBounce 0.8s ease-out;
            max-width: 500px;
        }

        @keyframes victoryBounce {
            0% { transform: scale(0.3) rotate(180deg); opacity: 0; }
            50% { transform: scale(1.05) rotate(90deg); opacity: 1; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        .victory-title {
            font-size: 3em;
            color: #1a5490;
            margin-bottom: 20px;
        }

        .victory-winner {
            font-size: 2em;
            color: #e63946;
            margin-bottom: 20px;
        }

        .victory-score {
            font-size: 1.5em;
            color: #666;
            margin-bottom: 30px;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .game-container {
                padding: 20px;
                margin: 10px;
            }

            h1 {
                font-size: 2em;
            }

            .game-modes {
                flex-direction: column;
                align-items: center;
            }

            .mode-card {
                min-width: 200px;
            }

            .pit {
                width: 60px;
                height: 60px;
            }

            .store {
                width: 80px;
                height: 100px;
            }

            .game-info {
                flex-direction: column;
                text-align: center;
            }
        }

        @media (max-width: 480px) {
            .pit {
                width: 50px;
                height: 50px;
            }

            .pit-stones {
                font-size: 1.2em;
            }

            .store {
                width: 70px;
                height: 80px;
            }

            .store-stones {
                font-size: 1.5em;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- Start Screen -->
        <div class="start-screen" id="startScreen">
            <h1>üêæ Paw Patrol Kalaha üêæ</h1>
            
            <div class="game-modes">
                <div class="mode-card" onclick="selectMode('ai', this)" ontouchstart="selectMode('ai', this); return false;">
                    <div class="mode-icon">ü§ñ</div>
                    <div class="mode-title">vs Computer</div>
                    <div class="mode-description">Spil mod en smart computermodstander</div>
                </div>
                
                <div class="mode-card" onclick="selectMode('human', this)" ontouchstart="selectMode('human', this); return false;">
                    <div class="mode-icon">üë•</div>
                    <div class="mode-title">2 Spillere</div>
                    <div class="mode-description">Spil mod en ven p√• samme enhed</div>
                </div>
            </div>

            <div class="avatar-selection" id="avatarSelection" style="display: none;">
                <h2>üéÆ V√¶lg din avatar:</h2>
                <div class="avatar-grid" id="avatarGrid"></div>
                
                <h2 id="player2AvatarTitle" style="display: none;">üéÆ Spiller 2 v√¶lger avatar:</h2>
                <div class="avatar-grid" id="player2AvatarGrid" style="display: none;"></div>
            </div>

            <button id="startButton" onclick="startGame()" disabled>Start Spil!</button>
        </div>

        <!-- Game Screen -->
        <div class="game-screen" id="gameScreen">
            <h1>üêæ Paw Patrol Kalaha üêæ</h1>
            
            <div class="game-info" id="gameInfo"></div>
            
            <div class="feedback" id="feedback"></div>
            
            <div class="game-board">
                <div class="hand" id="hand"></div>
                <div class="board-overlay" id="boardOverlay">
                    <div class="store" id="player2Store" style="left: 16%; top: 50%;">
                        <div class="store-label">Spiller 2</div>
                        <div class="store-stones" data-store="2"></div>
                    </div>

                    <div class="store" id="player1Store" style="left: 84%; top: 50%;">
                        <div class="store-label">Spiller 1</div>
                        <div class="store-stones" data-store="1"></div>
                    </div>
                </div>
            </div>

            <div style="text-align: center;">
                <button onclick="restartGame()">Nyt Spil</button>
            </div>
        </div>

        <!-- Victory Screen -->
        <div class="victory-overlay" id="victoryOverlay">
            <div class="victory-message">
                <div class="victory-title">üèÜ Vinder! üèÜ</div>
                <div class="victory-winner" id="victoryWinner"></div>
                <div class="victory-score" id="victoryScore"></div>
                <button onclick="restartGame()">Spil Igen</button>
            </div>
        </div>
    </div>

    <script>
        // Game State
        let gameMode = null;
        let player1Avatar = null;
        let player2Avatar = null;
        let currentPlayer = 1;
        let board = [];
        let gameActive = false;
        let animating = false;
        let playerSkillLevel = 1; // 1-5 scale
        let gameHistory = [];
        let moveHistory = [];
        let gameStartTime = 0;

        const STONE_IMAGE_SRC = 'round_rock.png';

        // Avatar Images
        const AVATAR_IMAGES = [
            '../../paw_patrol/download.jpeg',
            '../../paw_patrol/download (1).jpeg',
            '../../paw_patrol/download (2).jpeg',
            '../../paw_patrol/download (3).jpeg',
            '../../paw_patrol/download (4).jpeg',
            '../../paw_patrol/download (5).jpeg',
            '../../paw_patrol/images.jpeg',
            '../../paw_patrol/images (1).jpeg',
            '../../paw_patrol/images (2).jpeg',
            '../../paw_patrol/images (3).jpeg',
            '../../paw_patrol/images (4).jpeg',
            '../../paw_patrol/images (5).jpeg'
        ];

        // Initialize Game
        function initGame() {
            createAvatarGrids();
            setupBoard();
        }

        function createAvatarGrids() {
            const grid1 = document.getElementById('avatarGrid');
            const grid2 = document.getElementById('player2AvatarGrid');
            
            grid1.innerHTML = '';
            grid2.innerHTML = '';
            
            AVATAR_IMAGES.forEach((imgSrc, index) => {
                // Player 1 avatars
                const img1 = document.createElement('img');
                img1.src = imgSrc;
                img1.className = 'avatar-option';
                img1.onclick = () => selectAvatar(1, imgSrc, img1);
                img1.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    selectAvatar(1, imgSrc, img1);
                }, { passive: false });
                grid1.appendChild(img1);
                
                // Player 2 avatars
                const img2 = document.createElement('img');
                img2.src = imgSrc;
                img2.className = 'avatar-option';
                img2.onclick = () => selectAvatar(2, imgSrc, img2);
                img2.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    selectAvatar(2, imgSrc, img2);
                }, { passive: false });
                grid2.appendChild(img2);
            });
        }

        function selectMode(mode, clickedCard) {
            gameMode = mode;
            
            // Update UI
            document.querySelectorAll('.mode-card').forEach(card => {
                card.classList.remove('selected');
            });
            if (clickedCard) {
                clickedCard.classList.add('selected');
            }
            
            // Show avatar selection
            document.getElementById('avatarSelection').style.display = 'block';
            
            if (mode === 'human') {
                document.getElementById('player2AvatarTitle').style.display = 'block';
                document.getElementById('player2AvatarGrid').style.display = 'grid';
            }
        }

        function selectAvatar(player, avatarSrc, element) {
            if (player === 1) {
                player1Avatar = avatarSrc;
                document.querySelectorAll('#avatarGrid .avatar-option').forEach(el => {
                    el.classList.remove('selected');
                });
            } else {
                player2Avatar = avatarSrc;
                document.querySelectorAll('#player2AvatarGrid .avatar-option').forEach(el => {
                    el.classList.remove('selected');
                });
            }
            
            element.classList.add('selected');
            checkReadyToStart();
        }

        function checkReadyToStart() {
            const ready = gameMode && player1Avatar && (gameMode === 'ai' || player2Avatar);
            document.getElementById('startButton').disabled = !ready;
        }

        function setupBoard() {
            // Initialize board with 6 stones in each pit
            board = [
                [0, 6, 6, 6, 6, 6, 6], // Player 1: [store, pit1, pit2, pit3, pit4, pit5, pit6]
                [0, 6, 6, 6, 6, 6, 6]  // Player 2: [store, pit1, pit2, pit3, pit4, pit5, pit6]
            ];
        }

        function loadPlayerData() {
            // Load skill level and game history from localStorage
            const savedData = localStorage.getItem('nannaKalahaData');
            if (savedData) {
                const data = JSON.parse(savedData);
                playerSkillLevel = data.skillLevel || 1;
                gameHistory = data.gameHistory || [];
            }
        }

        function savePlayerData() {
            // Save skill level and game history to localStorage
            const data = {
                skillLevel: playerSkillLevel,
                gameHistory: gameHistory.slice(-20) // Keep last 20 games
            };
            localStorage.setItem('nannaKalahaData', JSON.stringify(data));
        }

        function evaluatePlayerPerformance() {
            if (gameMode !== 'ai' || moveHistory.length === 0) return;

            const gameTime = Date.now() - gameStartTime;
            const playerScore = board[0][0];
            const aiScore = board[1][0];
            const won = playerScore > aiScore;
            
            // Calculate performance metrics
            const performance = {
                won: won,
                scoreDifference: playerScore - aiScore,
                moveCount: moveHistory.length,
                gameTime: gameTime,
                efficiency: playerScore / moveHistory.length,
                date: new Date().toISOString()
            };

            // Add to history
            gameHistory.push(performance);
            
            // Update skill level based on recent performance
            updateSkillLevel(performance);
            
            // Save data
            savePlayerData();
            
            // Show feedback to Nanna
            showSkillFeedback(performance);
        }

        function updateSkillLevel(performance) {
            // Consider last 5 games for skill evaluation
            const recentGames = gameHistory.slice(-5);
            if (recentGames.length < 3) return; // Need at least 3 games to evaluate

            const winRate = recentGames.filter(g => g.won).length / recentGames.length;
            const avgEfficiency = recentGames.reduce((sum, g) => sum + g.efficiency, 0) / recentGames.length;
            
            // Adjust skill level based on performance
            if (winRate >= 0.8 && avgEfficiency > 2.5) {
                // Winning most games with good efficiency - increase difficulty
                playerSkillLevel = Math.min(5, playerSkillLevel + 1);
                showFeedback('Du spiller fantastisk! Sv√¶rhedsgrad √∏get! üåü', 'extra-turn');
            } else if (winRate <= 0.2 && avgEfficiency < 1.5) {
                // Struggling - decrease difficulty
                playerSkillLevel = Math.max(1, playerSkillLevel - 1);
                showFeedback('Lad os g√∏re det lidt nemmere! üí™', 'extra-turn');
            }
        }

        function showSkillFeedback(performance) {
            let feedback = '';
            if (performance.won) {
                if (performance.scoreDifference > 20) {
                    feedback = 'üèÜ Fantastisk sejr! Du er virkelig god til dette!';
                } else if (performance.scoreDifference > 10) {
                    feedback = 'üéâ Godt spillet! Du vandt med solid margin!';
                } else {
                    feedback = 'üëè Tillykke med sejren! T√¶t kamp!';
                }
            } else {
                if (performance.scoreDifference < -20) {
                    feedback = 'üí™ Godt fors√∏g! Computeren var st√¶rk i dag. Pr√∏v igen!';
                } else if (performance.scoreDifference < -10) {
                    feedback = 'üéØ T√¶t kamp! Du var t√¶t p√• at vinde!';
                } else {
                    feedback = 'ü§ù Uafgjort! I er j√¶vnbyrdige!';
                }
            }
            
            // Add skill level info
            feedback += `\nDin niveau: ${'‚≠ê'.repeat(playerSkillLevel)}`;
            
            setTimeout(() => {
                showFeedback(feedback, performance.won ? 'capture' : 'extra-turn');
            }, 1000);
        }

        function startGame() {
            // Hide start screen, show game screen
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            
            // Set player 2 avatar for AI mode
            if (gameMode === 'ai') {
                player2Avatar = '../../paw_patrol/zuma-labrador-retriever-puppy-clip-art-paw-patrol.jpg';
            }
            
            // Initialize game
            currentPlayer = 1;
            gameActive = true;
            animating = false;
            moveHistory = [];
            gameStartTime = Date.now();
            setupBoard();
            syncBoardToDom(true);
            updateGameInfo();
            
            // Show skill level for AI mode
            if (gameMode === 'ai') {
                showFeedback(`Spiller mod Computer (Niveau ${'‚≠ê'.repeat(playerSkillLevel)})`, 'extra-turn');
            } else {
                showFeedback('Spiller 1 starter!', 'extra-turn');
            }
        }

        function updateDisplay() {
            syncBoardToDom(false);
        }

        function getPitElement(player, pitIndex) {
            return document.getElementById(`pit${player}-${pitIndex}`);
        }

        function getStoreContainer(player) {
            return document.querySelector(`[data-store="${player}"]`);
        }

        function createStoneElement() {
            const img = document.createElement('img');
            img.src = STONE_IMAGE_SRC;
            img.className = 'stone';
            return img;
        }

        function pickUpStonesFromPit(player, pitIndex) {
            const hand = document.getElementById('hand');
            const pitEl = getPitElement(player, pitIndex);
            const container = pitEl ? pitEl.querySelector('.pit-stones') : null;
            const picked = [];
            if (!container) return picked;
            container.querySelectorAll('img.stone').forEach(st => {
                picked.push(st);
                hand.appendChild(st);
            });
            setStoneCountBadge(container, 0);
            return picked;
        }

        function randomStonePosition(el, countInContainer) {
            const radius = countInContainer <= 2 ? 12 : countInContainer <= 6 ? 18 : 22;
            const angle = Math.random() * Math.PI * 2;
            const r = Math.random() * radius;
            const x = 50 + Math.cos(angle) * r;
            const y = 50 + Math.sin(angle) * r;
            const rot = (Math.random() * 50 - 25).toFixed(1);
            el.style.setProperty('--x', `${x}%`);
            el.style.setProperty('--y', `${y}%`);
            el.style.setProperty('--rot', `${rot}deg`);
        }

        function setStoneCountBadge(container, count) {
            let badge = container.querySelector('.stone-count');
            if (!badge) {
                badge = document.createElement('div');
                badge.className = 'stone-count';
                container.appendChild(badge);
            }
            badge.textContent = count;
        }

        function renderContainerStones(container, count, maxRendered) {
            container.querySelectorAll('img.stone').forEach(n => n.remove());
            const toRender = Math.min(count, maxRendered);
            for (let i = 0; i < toRender; i++) {
                const stone = createStoneElement();
                randomStonePosition(stone, toRender);
                container.appendChild(stone);
            }
            setStoneCountBadge(container, count);
        }

        function syncBoardToDom(forceFullRender) {
            // Pits
            for (let i = 1; i <= 6; i++) {
                const pit1 = getPitElement(1, i);
                const pit2 = getPitElement(2, i);
                if (pit1) renderContainerStones(pit1.querySelector('.pit-stones'), board[0][i], 12);
                if (pit2) renderContainerStones(pit2.querySelector('.pit-stones'), board[1][i], 12);
            }

            // Stores (render fewer stones so it stays fast)
            const store1 = getStoreContainer(1);
            const store2 = getStoreContainer(2);
            if (store1) renderContainerStones(store1, board[0][0], 16);
            if (store2) renderContainerStones(store2, board[1][0], 16);
        }

        function updateGameInfo() {
            const gameInfo = document.getElementById('gameInfo');
            
            const player1Name = gameMode === 'ai' ? 'Dig' : 'Spiller 1';
            const player2Name = gameMode === 'ai' ? 'Computer' : 'Spiller 2';
            
            gameInfo.innerHTML = `
                <div class="player-info">
                    <img src="${player1Avatar}" class="player-avatar ${currentPlayer === 1 ? 'current' : ''}">
                    <div>
                        <div class="player-name ${currentPlayer === 1 ? 'current' : ''}">${player1Name}</div>
                        <div class="player-score ${currentPlayer === 1 ? 'current' : ''}">Point: ${board[0][0]}</div>
                    </div>
                </div>
                <div class="player-info">
                    <div>
                        <div class="player-name ${currentPlayer === 2 ? 'current' : ''}">${player2Name}</div>
                        <div class="player-score ${currentPlayer === 2 ? 'current' : ''}">Point: ${board[1][0]}</div>
                    </div>
                    <img src="${player2Avatar}" class="player-avatar ${currentPlayer === 2 ? 'current' : ''}">
                </div>
            `;
        }

        function createPits() {
            const overlay = document.getElementById('boardOverlay');
            if (!overlay) return;

            overlay.querySelectorAll('.pit').forEach(p => p.remove());

            // These coordinates are % positions tuned for kalaha_background_new.jpg.
            // If anything looks slightly off, we can adjust these numbers.
            const x = [33, 42, 51, 60, 69, 78];
            const yTop = 39.5;
            const yBottom = 61.0;

            // Player 2 pits (top row): left->right indexes 1..6
            for (let i = 1; i <= 6; i++) {
                const pit = document.createElement('div');
                pit.className = 'pit';
                pit.id = `pit2-${i}`;
                pit.dataset.player = '2';
                pit.dataset.pitIndex = String(i);
                pit.style.left = `${x[i - 1]}%`;
                pit.style.top = `${yTop}%`;
                pit.innerHTML = `<div class="pit-stones"></div>`;
                pit.onclick = () => makeMove(2, i);
                overlay.appendChild(pit);
            }

            // Player 1 pits (bottom row): left->right indexes 6..1 (so pit1 is closest to player1 store)
            for (let pos = 0; pos < 6; pos++) {
                const pitIndex = 6 - pos;
                const pit = document.createElement('div');
                pit.className = 'pit';
                pit.id = `pit1-${pitIndex}`;
                pit.dataset.player = '1';
                pit.dataset.pitIndex = String(pitIndex);
                pit.style.left = `${x[pos]}%`;
                pit.style.top = `${yBottom}%`;
                pit.innerHTML = `<div class="pit-stones"></div>`;
                pit.onclick = () => makeMove(1, pitIndex);
                overlay.appendChild(pit);
            }

            syncBoardToDom(true);
        }

        function makeMove(player, pitIndex) {
            if (!gameActive || animating || player !== currentPlayer) return;
            if (board[player - 1][pitIndex] === 0) {
                showFeedback('Denne br√∏nd er tom!', 'error');
                return;
            }
            
            // Get stones from the pit
            const stones = board[player - 1][pitIndex];
            board[player - 1][pitIndex] = 0;
            
            // Animate the move
            animateMove(player, pitIndex, stones);
        }

        function animateMove(player, startPit, stones) {
            animating = true;
            let currentStones = stones;
            let currentPit = startPit;
            let currentRow = player;

            const picked = pickUpStonesFromPit(player, startPit);

            let lastLandingRow = player;
            let lastLandingPit = startPit;
            let lastLandingWasStore = false;
            
            // Animation interval
            const interval = setInterval(() => {
                if (currentStones === 0) {
                    clearInterval(interval);
                    finishMove(player, lastLandingRow, lastLandingPit, lastLandingWasStore);
                    return;
                }
                
                // Move to next position
                currentPit++;
                if (currentPit === 7) {
                    // Reached store
                    if (currentRow === player) {
                        board[currentRow - 1][0]++;
                        const store = getStoreContainer(player);
                        if (store) {
                            const stoneEl = picked.pop() || createStoneElement();
                            randomStonePosition(stoneEl, Math.min(board[player - 1][0], 16));
                            stoneEl.classList.remove('drop');
                            void stoneEl.offsetWidth;
                            stoneEl.classList.add('drop');
                            store.appendChild(stoneEl);
                            setStoneCountBadge(store, board[player - 1][0]);
                        }
                        lastLandingRow = currentRow;
                        lastLandingPit = 0;
                        lastLandingWasStore = true;
                    }
                    currentPit = 0;
                    currentRow = currentRow === 1 ? 2 : 1;
                } else {
                    // Regular pit
                    board[currentRow - 1][currentPit]++;
                    const destPit = getPitElement(currentRow, currentPit);
                    const destContainer = destPit ? destPit.querySelector('.pit-stones') : null;
                    if (destContainer) {
                        const stoneEl = picked.pop() || createStoneElement();
                        randomStonePosition(stoneEl, Math.min(board[currentRow - 1][currentPit], 12));
                        stoneEl.classList.remove('drop');
                        void stoneEl.offsetWidth;
                        stoneEl.classList.add('drop');
                        destContainer.appendChild(stoneEl);
                        setStoneCountBadge(destContainer, board[currentRow - 1][currentPit]);
                    }

                    lastLandingRow = currentRow;
                    lastLandingPit = currentPit;
                    lastLandingWasStore = false;
                }
                
                currentStones--;
            }, 220);
        }

        function finishMove(player, lastRow, lastPit, lastWasStore) {
            // With simplified rules: continue sowing until you hit an empty pit
            // The last pit determines what happens next

            if (lastWasStore) {
                // Landed in store - extra turn!
                showFeedback('Ekstra tur!', 'extra-turn');
                updateGameInfo();
                animating = false;
                return;
            }
            
            // If last pit has stones, pick them up and continue sowing
            if (board[lastRow - 1][lastPit] > 0) {
                showFeedback('Forts√¶tter med at s√•!', 'extra-turn');
                
                // Pick up stones from last pit and continue sowing
                const continueStones = board[lastRow - 1][lastPit];
                board[lastRow - 1][lastPit] = 0;
                const picked = pickUpStonesFromPit(lastRow, lastPit);
                updateDisplay();
                
                // Continue sowing from this position
                setTimeout(() => {
                    animateContinueMove(lastRow, lastPit, continueStones, picked);
                }, 500);
                return;
            }
            
            // Landed in empty pit - turn ends
            showFeedback('Tur slut', 'capture');
            
            // Switch player
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            updateGameInfo();
            
            // Check for game end
            if (checkGameEnd()) {
                endGame();
                return;
            }
            
            // AI move
            if (gameMode === 'ai' && currentPlayer === 2) {
                setTimeout(() => makeAIMove(), 1000);
            } else {
                animating = false;
            }
        }

        function animateContinueMove(player, startPit, stones, picked) {
            let currentStones = stones;
            let currentPit = startPit;
            let currentRow = player;

            let lastLandingRow = player;
            let lastLandingPit = startPit;
            let lastLandingWasStore = false;
            
            // Animation interval
            const interval = setInterval(() => {
                if (currentStones === 0) {
                    clearInterval(interval);
                    finishMove(player, lastLandingRow, lastLandingPit, lastLandingWasStore);
                    return;
                }
                
                // Move to next position
                currentPit++;
                if (currentPit === 7) {
                    // Reached store
                    if (currentRow === player) {
                        board[currentRow - 1][0]++;
                        const store = getStoreContainer(player);
                        if (store) {
                            const stoneEl = (picked && picked.pop()) || createStoneElement();
                            randomStonePosition(stoneEl, Math.min(board[player - 1][0], 16));
                            stoneEl.classList.remove('drop');
                            void stoneEl.offsetWidth;
                            stoneEl.classList.add('drop');
                            store.appendChild(stoneEl);
                            setStoneCountBadge(store, board[player - 1][0]);
                        }

                        lastLandingRow = currentRow;
                        lastLandingPit = 0;
                        lastLandingWasStore = true;
                    }
                    currentPit = 0;
                    currentRow = currentRow === 1 ? 2 : 1;
                } else {
                    // Regular pit
                    board[currentRow - 1][currentPit]++;
                    const destPit = getPitElement(currentRow, currentPit);
                    const destContainer = destPit ? destPit.querySelector('.pit-stones') : null;
                    if (destContainer) {
                        const stoneEl = (picked && picked.pop()) || createStoneElement();
                        randomStonePosition(stoneEl, Math.min(board[currentRow - 1][currentPit], 12));
                        stoneEl.classList.remove('drop');
                        void stoneEl.offsetWidth;
                        stoneEl.classList.add('drop');
                        destContainer.appendChild(stoneEl);
                        setStoneCountBadge(destContainer, board[currentRow - 1][currentPit]);
                    }

                    lastLandingRow = currentRow;
                    lastLandingPit = currentPit;
                    lastLandingWasStore = false;
                }
                
                currentStones--;
            }, 220);
        }

        function makeAIMove() {
            showFeedback('Computeren t√¶nker...', 'extra-turn');
            
            setTimeout(() => {
                const bestMove = calculateBestMove();
                if (bestMove !== -1) {
                    makeMove(2, bestMove);
                }
            }, 1000);
        }

        function calculateBestMove() {
            const validPits = [];
            for (let i = 1; i <= 6; i++) {
                if (board[1][i] > 0) {
                    validPits.push(i);
                }
            }
            
            if (validPits.length === 0) return -1;
            
            // Adjust AI behavior based on skill level
            let bestMove = -1;
            let bestScore = -1;
            
            for (const pit of validPits) {
                let score = 0;
                const stones = board[1][pit];
                
                // Base scoring (applies to all levels)
                if ((pit + stones) % 7 === 0) {
                    score += 100; // Extra turn
                }
                
                const totalStones = pit + stones;
                let lastPit = totalStones % 7;
                let lastRow = 2;
                
                if (totalStones > 6 && totalStones < 13) {
                    lastRow = 1;
                    lastPit = totalStones - 6;
                }
                
                if (lastPit !== 0 && board[lastRow - 1][lastPit] > 0) {
                    score += board[lastRow - 1][lastPit] * 10; // Chain creation
                }
                
                // Skill level adjustments
                switch(playerSkillLevel) {
                    case 1: // Beginner - AI makes some mistakes
                        // 30% chance to make a random move instead
                        if (Math.random() < 0.3) {
                            score = Math.random() * 50;
                        }
                        // Don't look ahead too much
                        score += stones * 1;
                        break;
                        
                    case 2: // Easy - Basic strategy with some randomness
                        // 20% chance to make a random move
                        if (Math.random() < 0.2) {
                            score = Math.random() * 70;
                        }
                        // Basic defensive play
                        const simulatedBoard = simulateMove(2, pit);
                        const opponentScore = evaluateBoardForPlayer(simulatedBoard, 1);
                        score -= opponentScore * 3;
                        score += stones * 2;
                        break;
                        
                    case 3: // Medium - Balanced strategy
                        // 10% chance to make a random move
                        if (Math.random() < 0.1) {
                            score = Math.random() * 90;
                        }
                        // Good defensive play
                        const simulatedBoard2 = simulateMove(2, pit);
                        const opponentScore2 = evaluateBoardForPlayer(simulatedBoard2, 1);
                        score -= opponentScore2 * 5;
                        score += stones * 2;
                        break;
                        
                    case 4: // Hard - Strong strategy
                        // 5% chance to make a random move
                        if (Math.random() < 0.05) {
                            score = Math.random() * 95;
                        }
                        // Strong defensive play
                        const simulatedBoard3 = simulateMove(2, pit);
                        const opponentScore3 = evaluateBoardForPlayer(simulatedBoard3, 1);
                        score -= opponentScore3 * 8;
                        score += stones * 3;
                        break;
                        
                    case 5: // Expert - Optimal play
                        // Very little randomness
                        if (Math.random() < 0.02) {
                            score = Math.random() * 98;
                        }
                        // Maximum defensive play
                        const simulatedBoard4 = simulateMove(2, pit);
                        const opponentScore4 = evaluateBoardForPlayer(simulatedBoard4, 1);
                        score -= opponentScore4 * 10;
                        score += stones * 4;
                        break;
                }
                
                // Add small randomness to all levels
                score += Math.random() * 5;
                
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = pit;
                }
            }
            
            return bestMove;
        }

        function simulateMove(player, pitIndex) {
            // Create a copy of the board for simulation
            const simBoard = [
                [...board[0]],
                [...board[1]]
            ];
            
            let stones = simBoard[player - 1][pitIndex];
            simBoard[player - 1][pitIndex] = 0;
            let currentPit = pitIndex;
            let currentRow = player;
            
            while (stones > 0) {
                currentPit++;
                if (currentPit === 7) {
                    if (currentRow === player) {
                        simBoard[currentRow - 1][0]++;
                    }
                    currentPit = 0;
                    currentRow = currentRow === 1 ? 2 : 1;
                } else {
                    simBoard[currentRow - 1][currentPit]++;
                }
                stones--;
            }
            
            return simBoard;
        }

        function evaluateBoardForPlayer(boardState, player) {
            // Evaluate how good a board position is for a player
            let score = 0;
            
            // Store stones are most valuable
            score += boardState[player][0] * 10;
            
            // Stones in pits are valuable based on position
            for (let i = 1; i <= 6; i++) {
                // Pits closer to store are slightly more valuable
                const positionBonus = Math.abs(i - 4) * 0.5;
                score += boardState[player][i] * (1 + positionBonus);
            }
            
            // Having stones in pits that can create chains is valuable
            for (let i = 1; i <= 6; i++) {
                if (boardState[player][i] > 0) {
                    // Check if this pit can land in store
                    if ((i + boardState[player][i]) % 7 === 0) {
                        score += 20;
                    }
                    
                    // Check if this pit can create chains
                    const totalStones = i + boardState[player][i];
                    let lastPit = totalStones % 7;
                    let lastRow = player;
                    
                    if (totalStones > 6 && totalStones < 13) {
                        lastRow = player === 1 ? 2 : 1;
                        lastPit = totalStones - 6;
                    }
                    
                    if (lastPit !== 0 && boardState[lastRow][lastPit] > 0) {
                        score += boardState[lastRow][lastPit] * 5;
                    }
                }
            }
            
            return score;
        }

        function checkGameEnd() {
            // Check if one player's pits are all empty
            const player1Empty = board[0].slice(1).every(stones => stones === 0);
            const player2Empty = board[1].slice(1).every(stones => stones === 0);
            
            return player1Empty || player2Empty;
        }

        function endGame() {
            gameActive = false;
            
            // Collect remaining stones
            for (let player = 1; player <= 2; player++) {
                for (let pit = 1; pit <= 6; pit++) {
                    board[player - 1][0] += board[player - 1][pit];
                    board[player - 1][pit] = 0;
                }
            }
            
            updateDisplay();
            
            // Evaluate performance and update skill level
            evaluatePlayerPerformance();
            
            // Determine winner
            const player1Score = board[0][0];
            const player2Score = board[1][0];
            
            let winner, winnerText;
            if (player1Score > player2Score) {
                winner = 1;
                winnerText = gameMode === 'ai' ? 'Du vandt!' : 'Spiller 1 vandt!';
            } else if (player2Score > player1Score) {
                winner = 2;
                winnerText = gameMode === 'ai' ? 'Computeren vandt!' : 'Spiller 2 vandt!';
            } else {
                winnerText = 'Uafgjort!';
            }
            
            // Show victory screen
            document.getElementById('victoryWinner').textContent = winnerText;
            document.getElementById('victoryScore').textContent = 
                `Spiller 1: ${player1Score} | ${gameMode === 'ai' ? 'Computer' : 'Spiller 2'}: ${player2Score}`;
            document.getElementById('victoryOverlay').style.display = 'flex';
        }

        function showFeedback(message, type) {
            const feedback = document.getElementById('feedback');
            feedback.textContent = message;
            feedback.className = `feedback ${type}`;
            
            setTimeout(() => {
                feedback.textContent = '';
                feedback.className = 'feedback';
            }, 2000);
        }

        function restartGame() {
            document.getElementById('victoryOverlay').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('startScreen').style.display = 'block';
            
            // Reset selections
            gameMode = null;
            player1Avatar = null;
            player2Avatar = null;
            document.getElementById('startButton').disabled = true;
            document.querySelectorAll('.mode-card').forEach(card => {
                card.classList.remove('selected');
            });
            document.querySelectorAll('.avatar-option').forEach(el => {
                el.classList.remove('selected');
            });
            
            if (gameMode === 'human') {
                document.getElementById('player2AvatarTitle').style.display = 'none';
                document.getElementById('player2AvatarGrid').style.display = 'none';
            }
        }

        // Initialize on load
        window.onload = () => {
            loadPlayerData(); // Load saved skill level and history
            initGame();
            createPits();
        };
    </script>
</body>
</html>
